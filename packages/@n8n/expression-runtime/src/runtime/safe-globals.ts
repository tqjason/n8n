// ============================================================================
// Safe Wrappers for Security-Sensitive Globals
// ============================================================================

/**
 * SafeObject - Blocks dangerous Object methods that could lead to RCE
 *
 * Blocked methods:
 * - defineProperty, setPrototypeOf: Prevent prototype pollution
 * - getOwnPropertyDescriptor: Prevent property descriptor manipulation
 * - __defineGetter__, __defineSetter__: Legacy descriptor manipulation
 */
export const SafeObject = new Proxy(Object, {
	get(target, prop) {
		// Block dangerous methods (return undefined)
		const blockedMethods = [
			'defineProperty',
			'defineProperties',
			'setPrototypeOf',
			'getOwnPropertyDescriptor',
			'getOwnPropertyDescriptors',
			'__defineGetter__',
			'__defineSetter__',
			'__lookupGetter__',
			'__lookupSetter__',
		];

		if (blockedMethods.includes(prop as string)) {
			return undefined;
		}

		// Block getPrototypeOf by throwing (more secure than returning undefined)
		if (prop === 'getPrototypeOf') {
			throw new Error('Object.getPrototypeOf is not allowed');
		}

		// Allow other Object methods
		const value = (target as any)[prop];
		if (typeof value === 'function') {
			// Use arrow function wrapper to preserve 'this' binding
			return (...args: any[]) => value.apply(target, args);
		}
		return value;
	},
});

/**
 * SafeError - Blocks stack manipulation methods
 *
 * Blocked properties:
 * - stackTraceLimit, captureStackTrace, prepareStackTrace: Prevent stack manipulation attacks
 */
export const SafeError = new Proxy(Error, {
	get(target, prop) {
		// Block stack manipulation (return undefined)
		const blockedProps = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];
		if (blockedProps.includes(prop as string)) {
			return undefined;
		}

		// Block dangerous methods
		const blockedMethods = ['__defineGetter__', '__defineSetter__'];
		if (blockedMethods.includes(prop as string)) {
			return undefined;
		}

		const value = (target as any)[prop];
		if (typeof value === 'function') {
			return (...args: any[]) => value.apply(target, args);
		}
		return value;
	},
	set(target, prop, value) {
		// Block setting prepareStackTrace
		if (prop === 'prepareStackTrace') {
			return false;
		}
		(target as any)[prop] = value;
		return true;
	},
});

// ============================================================================
// ExpressionError - used by tournament-generated error handlers
// ============================================================================

export class ExpressionError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'ExpressionError';
	}
}

// ============================================================================
// Runtime sanitizer for dynamic property access
// Generated by PrototypeSanitizer: obj[expr] â†’ obj[this.__sanitize(expr)]
// Must match the blocklist in packages/workflow/src/expression-sandboxing.ts
// ============================================================================

const unsafeObjectProperties = new Set([
	'__proto__',
	'prototype',
	'constructor',
	'__defineGetter__',
	'__defineSetter__',
	'__lookupGetter__',
	'__lookupSetter__',
	'toString',
	'valueOf',
	'toLocaleString',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
]);

export function __sanitize(value: unknown): unknown {
	if (typeof value === 'string' && unsafeObjectProperties.has(value)) {
		throw new ExpressionError(`Cannot access "${value}" due to security concerns`);
	}
	return value;
}
